00000000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/3/2020 11:12:04 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Program    : 3
00000000                             3  * Written by : Tony Giumenta
00000000                             4  * Date       : 09/21/20
00000000                             5  * Description: A subroutine which draws a bmp file to the console 
00000000                             6  *              window given parameters outlined in the main.x68 pixel-by-pixel
00000000                             7  *              This subroutine assumes that the file is saved using 32-bit color depth.
00000000                             8  *
00000000                             9  * The arguments and descriptions are listed as follows:
00000000                            10  * CornerDisplayX and CornerDisplayY -- The ordered pair that indicates the top-left corner of the image.
00000000                            11  *                                      This ordered pair is relative to the overall dimensions.
00000000                            12  * WidthDisplay -- How many pixels wide to print. This is not relative to the overall dimensions.
00000000                            13  * HeightDisplay -- How many pixels high to print. This is not relative to the overall dimensions.
00000000                            14  * LocationScreenX and LocationScreenY -- The ordered pair that indicates the offset from the top-left corner
00000000                            15  *                                        of the console window.
00000000                            16  *-----------------------------------------------------------
00000000  =00000008                 17  RotateSwapVal       EQU     8       ; Rotation amount for byteswapping values and for fixing padding
00000000  =00000002                 18  PixelToByteVal      EQU     2       ; Shift amount to convert from pixels to bytes
00000000  =0000000A                 19  PixelOffset         EQU     $0A     ; Location of offset for pixel array
00000000                            20  
00000000                            21  *Stack offset reference values*
00000000  =00000008                 22  CornerDisplayXRef   EQU     $8  
00000000  =0000000C                 23  CornerDisplayYRef   EQU     $C  
00000000  =00000010                 24  WidthDisplayRef     EQU     $10 
00000000  =00000014                 25  WidthFileOffsetRef  EQU     $14 
00000000  =00000018                 26  HeightFileOffsetRef EQU     $18 
00000000  =0000001C                 27  HeightDisplayRef    EQU     $1C 
00000000  =00000020                 28  LocationScreenXRef  EQU     $20 
00000000  =00000024                 29  LocationScreenYRef  EQU     $24 
00000000                            30  
00000000                            31  *Stack offset reference values for locals*
00000000  =00000008                 32  AmountOfSpace       EQU     8           ; Space amount needed for locals
00000000  =00000000                 33  WidthCoordOffset    EQU     $0      
00000000  =00000004                 34  HeightCoordOffset   EQU     $4      
00000000                            35  
00000000  =00F200FF                 36  TransparentColor    EQU     $00F200FF   ; If the pen color is this color, don't draw it, act as transparent
00000000                            37  
00000000                            38  *A subroutine that byteswaps values -- mainly used for interpreting values in the BMP*
00000000                            39  ByteSwap
00000000  E058                      40      ror.w   #RotateSwapVal, d0  ; Swapping the first word's byte
00000002  4840                      41      swap    d0                  ; Swapping both words in the long word
00000004  E058                      42      ror.w   #RotateSwapVal, d0  ; Swapping the second word's byte
00000006  4E75                      43      rts
00000008                            44  
00000008                            45  *Start Subroutine by allocating space for future local variables and byteswapping values*
00000008                            46  DrawBitmap
00000008                            47      ;movem.l d0-d7/a0-a6, -(sp) ; Save all original variables onto the stack
00000008                            48                                 ; This allows the use of d0-d7 as temporary spaces now
00000008  518F                      49      sub.l   #AmountOfSpace,sp  ; Make room for two local variables (coordinates) and set stack pointer
0000000A                            50  
0000000A                            51  *Byte Swaps the start of the pixel array*
0000000A                            52  ByteSwapPixelArray    
0000000A  2028 000A                 53      move.l  PixelOffset(a0),d0
0000000E  4EB8 0000                 54      jsr     ByteSwap           ; ByteSwap the pixel offset
00000012  49F0 0000                 55      lea     (a0,d0),a4         ; Loads beginning of the pixel array
00000016                            56      
00000016                            57  *Byte Swaps the width that was native to the .bmp file to be useable for drawing*
00000016                            58  ByteSwapWidth
00000016  3003                      59      move.w  d3,d0       ; Move width into temporary storage
00000018  4EB8 0000                 60      jsr     ByteSwap
0000001C  4840                      61      swap    d0          ; Final swap since the value is only a word and not a long
0000001E  3600                      62      move.w  d0,d3       ; Move the swapped value back into the width register    
00000020                            63     
00000020                            64  *Byte Swaps the height that was native to the .bmp file to be useable for drawing*
00000020                            65  ByteSwapHeight
00000020  3004                      66      move.w  d4,d0       ; Move width into temporary storage
00000022  4EB8 0000                 67      jsr     ByteSwap
00000026  4840                      68      swap    d0          ; Final swap since the value is only a word and not a long
00000028  3800                      69      move.w  d0,d4       ; Move the swapped value back into the width register
0000002A                            70      
0000002A                            71  *Gets information about number of rows to skip, as well as setting height coordinate/draw-counters*
0000002A                            72  HeightShiftUp   
0000002A  2A04                      73      move.l  d4, d5                      ; Move height into temporary space
0000002C  9AAF 001C                 74      sub.l   HeightDisplayRef(sp),d5     ; Get the number of rows to skip from the bottom of the image
00000030  9AAF 000C                 75      sub.l   CornerDisplayYRef(sp),d5    ; Get the number of rows to skip from the top (and bottom)
00000034  2C2F 001C                 76      move.l  HeightDisplayRef(sp),d6     ; Stores the amount of rows to start drawing considering the Y offset
00000038                            77                                          ; Stores the height draw-counter
00000038  2F46 0004                 78      move.l  d6,HeightCoordOffset(sp)
0000003C                            79      
0000003C                            80  *Skips the amount of rows (in bytes) based on the height offset*
0000003C                            81  RowStartByteSkip
0000003C  2E03                      82      move.l  d3,d7                       ; Move the full width of the image (in pixels) in a temporary space
0000003E  CEC5                      83      mulu.w  d5,d7                       ; Multiply this width by the number of rows needed to skip
00000040  E587                      84      asl.l   #PixelToByteVal,d7 
00000042  D9C7                      85      adda.l  d7,a4                       ; Skip to start initially reading pixels at correct height offset
00000044                            86      
00000044                            87  *Stores the amount of bytes to skip from both left and right of each row*
00000044                            88  WidthByteSkip
00000044  2A03                      89      move.l  d3,d5                       ; Reuse temporary space to store width
00000046  9AAF 0010                 90      sub.l   WidthDisplayRef(sp),d5      ; Gets how many "columns" to skip based on height
0000004A  9AAF 0008                 91      sub.l   CornerDisplayXRef(sp),d5    ; Gets how many "columns" to skip based on offset and height
0000004E  262F 0010                 92      move.l  WidthDisplayRef(sp),d3      ; Number of pixels to print per row
00000052                            93      
00000052  2E05                      94      move.l  d5,d7                       ; Reuse temporary space to get the number of pixels to skip at end of row printing
00000054  E587                      95      asl.l   #PixelToByteVal,d7
00000056                            96      
00000056  282F 0008                 97      move.l  CornerDisplayXRef(sp),d4    ; Use an unused space to get number of pixels to skip from left of image
0000005A  E584                      98      asl.l   #PixelToByteVal, d4
0000005C                            99      
0000005C                           100  *Resets width counters, coordinates and shift address offset to account for offset*
0000005C                           101  CounterAndCoordinateSetup
0000005C  0CAF 00000000 0004       102      cmp.l   #0,HeightCoordOffset(sp)    ; If height coordinate is less than or equal to 0, done with subroutine
00000064  6F00 0048                103      ble     Done
00000068  42AF 0000                104      clr.l   WidthCoordOffset(sp)        ; Reset width coordinate/counter
0000006C  D9C4                     105      adda.l  d4, a4                      ; Start reading pixels from correct offset
0000006E                           106      
0000006E                           107  *Main drawing loop which sets pen colors and drawing location*
0000006E                           108  DrawingLoop
0000006E  221C                     109      move.l  (a4)+, d1                   ; Move pen color into d1 and advance address to look at next pixel
00000070  E099                     110      ror.l   #RotateSwapVal,d1           ; Rotate to fix padding and converts the RGB->BGR
00000072                           111      
Line 112 ERROR: Undefined symbol
00000072  203C 004DBD16            112      move.l  #PenColorTrap, d0
00000078  4E4F                     113      trap    #15                         ; Sets pen color
0000007A  0C81 00F200FF            114      cmpi.l  #TransparentColor,d1        ; If the color is equal to the transparent color, don't draw the pixel
00000080  6700 001A                115      beq     SetWidthInformation
00000084                           116  
00000084                           117  *Conditionally draws the pixel*
00000084                           118  DrawPixel
00000084  222F 0000                119      move.l  WidthCoordOffset(sp),d1     ; Move width coordinate into proper location for drawing
00000088  D2AF 0020                120      add.l   LocationScreenXRef(sp),d1   ; Shift width coordinate based on offset
0000008C  242F 0004                121      move.l  HeightCoordOffset(sp),d2    ; Move height coordinate into proper location for drawing
00000090  D4AF 0024                122      add.l   LocationScreenYRef(sp),d2   ; Shift height coordinate based on offset
Line 123 ERROR: Undefined symbol
00000094  203C 004DBD16            123      move.l  #DrawPixelTrap,d0      
0000009A  4E4F                     124      trap    #15                         ; Draws pixel
0000009C                           125  
0000009C                           126  *Increments counters and checks if the last pixel in the row has been drawn*
0000009C                           127  SetWidthInformation
0000009C  52AF 0000                128      addi.l  #1, WidthCoordOffset(sp)    ; Increment width coordinate/counter
000000A0  B6AF 0000                129      cmp.l   WidthCoordOffset(sp),d3     ; If width counter is less than width of the image, keep drawing
000000A4  6EC8                     130      bgt     DrawingLoop
000000A6                           131  
000000A6                           132  *Shift address and set height coordinate to ensure pixel drawing occurs at correct location*
000000A6                           133  AddressAndStackTidying
000000A6  D9C7                     134      adda.l  d7,a4                       ; Shift over necessary bytes to compensate pixels on the right
000000A8  53AF 0004                135      subi.l  #1,HeightCoordOffset(sp)    ; Decrement height coordinate
000000AC  60AE                     136      bra     CounterAndCoordinateSetup
000000AE                           137      
000000AE                           138  *Fixing Stack and returning to main*
000000AE                           139  Done
000000AE  508F                     140      add.l   #AmountOfSpace,sp           ; Set stack pointer back to return properly
000000B0                           141      ;movem.l (sp)+,d0-d7/a0-a6           ; Reset original registers and fix stack pointer
000000B0  4E75                     142      rts                                 ; Return from subroutine back to main
000000B2                           143  
000000B2                           144  
000000B2                           145  
000000B2                           146  
000000B2                           147  
000000B2                           148  
000000B2                           149  
000000B2                           150  
000000B2                           151  
000000B2                           152  
Line 153 WARNING: END directive missing, starting address not set

2 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESSANDSTACKTIDYING  A6
AMOUNTOFSPACE       8
BYTESWAP            0
BYTESWAPHEIGHT      20
BYTESWAPPIXELARRAY  A
BYTESWAPWIDTH       16
CORNERDISPLAYXREF   8
CORNERDISPLAYYREF   C
COUNTERANDCOORDINATESETUP  5C
DONE                AE
DRAWBITMAP          8
DRAWINGLOOP         6E
DRAWPIXEL           84
HEIGHTCOORDOFFSET   4
HEIGHTDISPLAYREF    1C
HEIGHTFILEOFFSETREF  18
HEIGHTSHIFTUP       2A
LOCATIONSCREENXREF  20
LOCATIONSCREENYREF  24
PIXELOFFSET         A
PIXELTOBYTEVAL      2
ROTATESWAPVAL       8
ROWSTARTBYTESKIP    3C
SETWIDTHINFORMATION  9C
TRANSPARENTCOLOR    F200FF
WIDTHBYTESKIP       44
WIDTHCOORDOFFSET    0
WIDTHDISPLAYREF     10
WIDTHFILEOFFSETREF  14
